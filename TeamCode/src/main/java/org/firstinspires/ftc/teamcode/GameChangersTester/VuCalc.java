package org.firstinspires.ftc.teamcode.GameChangersTester;

import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;
import org.firstinspires.ftc.robotcore.external.matrices.VectorF;
import org.firstinspires.ftc.robotcore.external.navigation.Orientation;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;

import ftc.electronvolts.util.TeamColor;
import ftc.electronvolts.util.Vector2D;
import ftc.electronvolts.util.units.Angle;
import ftc.evlib.hardware.sensors.HeadingSource;

import static org.firstinspires.ftc.robotcore.external.navigation.AngleUnit.DEGREES;
import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.XYZ;
import static org.firstinspires.ftc.robotcore.external.navigation.AxesReference.EXTRINSIC;

public class VuCalc implements HeadingSource {

    // xDestIn and yDestIn are both in the vuforia frame of reference and are vuforia coords
    private final double xDestIn;
    private final double yDestIn;
    private final VuforiaTrackable trackable;
    private static final double mmPerInch = 25.4f;
    //offset between vuforia frame and robot frame
    public final double orientationTransformation = -90;
    public final double headingOffset;

    private Vector2D translation;
    private double heading;

    private VectorF currentPos;

    public VuCalc(double xDestIn, double yDestIn, VuforiaTrackable trackable, TeamColor tc) {
        this.xDestIn = xDestIn;
        this.yDestIn = yDestIn;
        this.trackable = trackable;
        if(tc == TeamColor.BLUE)
            headingOffset = 0;
        else
            headingOffset = 0;

    }


    public void update() {
        if (((VuforiaTrackableDefaultListener) trackable.getListener()).isVisible()) {
            // getUpdatedRobotLocation() will return null if no new information is available since
            // the last time that call was made, or if the trackable is not currently visible.
            OpenGLMatrix robotLocation = ((VuforiaTrackableDefaultListener) trackable.getListener()).getUpdatedRobotLocation();
            if (robotLocation != null) {

                // calculates the vector translation in inches
                currentPos = robotLocation.getTranslation();
//                translation = (xDestIn - currentPos.get(0))/(yDestIn - currentPos.get(1)));
                // the xDestIn and yDestIn are both gathered from vuforia and are used to create a vector that is generated by the vuforia input
                double deltaX = xDestIn - (currentPos.get(0)/mmPerInch);
                double deltaY = yDestIn - (currentPos.get(1)/mmPerInch);
                // translation distance is in inches
                Vector2D vuVec = new Vector2D(deltaX, deltaY);
                // transform the vector that is in the vuforia frame of reference to the robot frame of reference
                // transforming the heading as well to the robot frame, you have to translate by 90 to the left to go to the robot frame, heavily dependent on robot location
                translation = new Vector2D(vuVec.getLength(), Angle.fromDegrees(vuVec.getDirection().degrees() + orientationTransformation));
                Orientation rotation = Orientation.getOrientation(robotLocation, EXTRINSIC, XYZ, DEGREES);
                double rawHeading = HeadingFixer.fix(rotation.thirdAngle, trackable.getName(), rotation.firstAngle);
                heading = rawHeading + headingOffset;
            }
        }

    }

    @Override
    // robot frame heading
    public double getHeading() {
        return heading;
    }
    // robot frame translation
    public Vector2D getTranslation(){
        return  translation;
    }
    //vuforia frame pos
    public VectorF getVuCurrentPos(){
        return currentPos;
    }
}
